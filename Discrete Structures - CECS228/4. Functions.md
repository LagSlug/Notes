
# 4.0 Functions

- A function maps elements from one set to another.
- Many functions are mathematical functions that map numbers to numbers.
- Discrete mathematics deals with functions that map between other kinds of sets, such as binary strings or a set of tasks.
- E.g mapping assignments of people to teams or guests to hotel rooms.

# 4.1 Introduction to Functions

-   A <u>function</u> f maps elements of a set X to elements of a set Y.
-   f is a subset of X×Y such that for every x ∈ X, there is exactly one y ∈ Y for which (x, y) ∈ f.

### Function Notation

#### f: X → Y
- f: X → Y represents the fact that f is a function from X to Y.
   
- (x, y) ∈ f if f maps x to y.

#### f(x) = y
- f(x) = y is an alternate notation to show that f maps x to y (or (x, y) ∈ f).

- A function from X to Y can be viewed as a subset of X × Y.
- It is possible that X and Y are the same set, in which case f is a subset of X × X.

### Domain and Target (Co-Domain)

Given: f(x) = y

- X is called the <u>domain</u> of f.
- Y is the <u>target</u> (or <u>co-domain</u>) of f.

### Well Defined Functions

- If f maps an element of the domain to zero or multiple elements of the target, it is not well-defined.

### Arrow Diagrams

- A function f that maps X to Y and has a finite set X can be specified by listing the pairs (x, y) in f.
- An <u>arrow diagram</u> can also be used to represent a function with a finite domain.
- In an arrow diagram, the domain X is listed on the left and the target Y is listed on the right.

![](Discrete%20Structures%20-%20CECS228/attachments/function-arrow-diagram.svg)

- There is an arrow from x ∈ X to y ∈ Y if and only if (x, y) ∈ f.
- Since f is a function, each x ∈ X has exactly one y ∈ Y such that (x, y) ∈ f.
- In the arrow diagram for a function, there is exactly one arrow pointing out of every element in the domain.

### Range

- The range of function f: X → Y is the set of all possible output values (y) that can be obtained by inputting values (x) from X into the function.
- It can be expressed in set notation as: 
  Range of f = { y: (x, y) ∈ f, for some x ∈ X }

- The range is a subset of the target set Y, but it may not necessarily be equal to Y.
- In an arrow diagram, the range is represented by the set of elements in the target set Y that have arrows pointing to them.

### Must Specifiy a Domain and Target

- A mathematical function f is defined by how it acts on an input x.
- The definition must specify the domain and target of f.
  
- Example: abs: R → R, where abs(x) = |x|.
- The function abs maps every real number to a real number.
- However, abs does not map any number to a negative number.

### Strings

- Functions can have domain and target sets that consist of strings.
	
	E.g. 
	f: {0, 1}<sup>n</sup> → {0, 1}<sup>(n + 1)</sup>

- f is a function that takes a binary string of length n, and returns a binary string of length n + 1.

#### Example: Parity Bits

```typescript
/** Appends an even parity bit to a binary string */
function addParityBit(binaryString: string): string {
  let sum = 0;

  // calculate the sum of all 1's in the binary string
  for (let i = 0; i < binaryString.length; i++) {
    if (binaryString[i] === '1') {
      sum++;
    }
  }

  // determine the parity based on the sum
  const parityBit = (sum % 2 === 0) ? '0' : '1';

  // return the binary string with the parity bit appended
  return binaryString + parityBit;
}
```

- This function takes an n-bit string as input, and outputs an (n+1)-bit string.
- Generally, for any x ∈ {0, 1}<sup>n</sup>, f(x) = x{0, 1}<sup>1</sup>.
	
	E.g. 
	addParityBit("1001") = "1001**0**"
	addParityBit("1011") = "1011**1**"
	  
### Function equality

- Two functions, f and g, are equal if they have the same domain and target and f(x) = g(x) for every element x in the domain.
- The notation f = g is used to indicate that functions f and g are equal.

# 4.2 Ceiling and Floor Functions

- The floor and ceiling functions map real numbers onto integers
- <u>Floor</u> function rounds real numbers down to the nearest integer
- <u>Ceiling</u> function rounds real numbers up to the nearest integer

### Ceiling Function

- The ceiling function maps a real number to the nearest integer in the upward direction.
- It is denoted:
  ceiling: **R** → **Z**, 
  where ceiling(x) = the smallest integer y such that x ≤ y.

#### Examples
- ceiling(π) = 4
- ceiling(5.5) = 6
- ceiling(-2.5) = -2 
- ceiling(-4) = -4.

### Floor Function

- The floor function maps a real number to the nearest integer in the downward direction.
- It is denoted:
  
  floor: **R** → **Z**, 
  where floor(x) = the largest integer y such that y ≤ x.

#### Examples
- floor(π) = 3
- floor(5.5) = 5
- floor(-2.5) = -3 
- floor(-4) = -4.

### Ceiling and Floor Notation

$$
	\begin{aligned}
	\mbox{floor}(x) &= \lfloor x \rfloor \\ \\
	\mbox{ceiling}(x) &= \lceil x \rceil
	\end{aligned}
$$

# 4.3 Properties of functions

### One-to-one or Injective function
- A one-to-one function has a single target element for each element in the domain.
- If x<sub>1</sub> ≠ x<sub>2</sub>, then f(x<sub>1</sub>) ≠ f(x<sub>2</sub>)  
- An injective function f maps different elements in X to different elements in Y.
- In an arrow diagram, a one-to-one function no target element will have two arrows pointed at itself.
  
### Onto or Surjective function
- An onto function has a target set that is fully covered by the function.
- Range of f is equal to target Y
- For every y ∈ Y, there is an x ∈ X such that f(x) = y.
- In an arrow diagram, an onto function every target element will have an arrow pointed at itself.

### Bijective Functions

- A <u>bijective function</u> is both one-to-one and onto. 
- A bijective function is also known as a bijection. 
- A bijection can also be referred to as a <u>one-to-one correspondence</u>.

### Size Implications

- Function with finite domain and target can reveal information about their relative sizes.
- One-to-one or onto property of function used to infer this information.

Consider the function f: D → T

1. Onto:
    - |D| ≥ |T|.
    - This means that for every element in the target, there is at least one element in the domain.

2. One-to-one:
    - |D| ≤ |T|.
    - This means that every element in the domain maps to a unique element in the target.

3. Bijection:
    - |D| ≤ |T| and |D| ≥ |T|.
    - This implies that |D| = |T|.

![](Discrete%20Structures%20-%20CECS228/attachments/zybooks-relative-sizes-of-domain-and-target.svg)
[Credit: Zybooks](https://learn.zybooks.com/zybook/CSULBCECS228MehrniaSpring2023/chapter/4/section/3)

### Counting Elements with Bijection Between sets

- To count elements in a set, define a bijection between that set and another set with a known size.

# 4.4 The Inverse of a Function

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		A function f has an inverse if and only if f is a bijection.
	</div>
</div>

- A bijection function f: X → Y has an inverse denoted by f<sup>-1</sup>.
- To obtain the inverse of f, exchange the first and second entries in each pair in f.

- Reversing pairs in a function doesn't always give a well-defined function.
- Some functions don't have an inverse.
- Function f: X → Y has an inverse only if reversing pairs in f results in a well-defined function from Y to X.
- f<sup>-1</sup> is a well-defined function if every element in Y is mapped to exactly one element in X.

### Inverse Function Notation

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>Define</u>
		f(x) = y to be a bijective function.
		
		<u>Implies</u>
		f<sup>-1</sup>(y) = x
		
		Read: "f inverse of y equals x."
	</div>
</div>


### Inverse Composition Identity

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		For every element x ∈ X, 
		f<sup>-1</sup>( f(x) ) = x.
		
		f( f<sup>-1</sup>(x) ) = x.
		
	</div>
</div>

- The composition of f and f<sup>-1</sup> is an identity function.

### Restricting Domain to Assert Bijective Definition

- The function f(x) = x<sup>2</sup> is not one-to-one, because f(x) = f(-x) for any real number x.
- If the domain is restricted to positive real numbers, then f(x) = x<sup>2</sup> is a bijection.
- Since each positive real number has a unique square root, the inverse of f(x) = x<sup>2</sup> can exist.
  
<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>Restrict domain</u> to all positive real numbers
		f: ℝ<sup>+</sup> → ℝ<sup>+</sup>
		f(x) = x<sup>2</sup>
		
		Since f(x) is bijective, f<sup>-1</sup> is well-defined.
		f<sup>-1</sup>(y) = <span style="font-size: 25px;">&#8730;</span><span  style="text-decoration: overline; transform: translateX(-4px); display: inline-block;">&nbsp;y&nbsp;</span>
	</div>
</div>


# 4.5 Composition of functions

- <u>Composition</u> refers to applying a function to the result of another function.
- The composition of two functions f and g is denoted as: g o f.
- It is read "g of f".
- The composition of functions creates a new function.
  
<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>Define</u>
		f: X → Y and g: Y → Z
		
		<u>The Composition of g with f</u>
		{ (g ο f ): X → Z | for all x ∈ X }
		(g ο f )(x) = g( f(x) )
	</div>
</div>

- Function order matters; f ο g ≠ g ο f.

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>Define</u>
    f: R+ → R+, f(x) = x<sup>3</sup>
    g: R+ → R+, g(x) = x + 2
		
		<u>Expand Compositions</u>
    (f ο g)(x) = f(g(x)) = (x + 2)<sup>3<sup></sup></sup>
    
    (g ο f)(x) = g(f(x)) = x<sup>3</sup> + 2
	</div>
</div>

- More than two functions can be composed, and composition itself is associative.

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		f ο g ο h = (f ο g) ο h = f ο (g ο h) = f(g(h(x)))
	</div>
</div>

### Identity Function

- The <u>identity function</u> maps each element of a set to itself, and always maps a set to itself.

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>The identity function on A</u> 
		
		I<sub>A</sub>: A → A, is defined as I<sub>A</sub>(a) = a, for all a ∈ A.
	</div>
</div>

- When a function f from set A to set B has an inverse, the composition of f with its inverse yields the identity function.

# 4.6 Logarithms and exponents

- The exponential function exp<sub>b</sub>: ℝ → ℝ<sup>+</sup> is defined as:
 $$
 \displaylines {
	 \mbox{exp}_b(x) = b^x \\
	 \text{where b is a positive real number and b ≠ 1}
 }
 $$
- In the expression b<sup>x</sup>, the parameter b is called the "base" of the function, and the input x is called the "exponent".

### Properties of Exponents

- Consider the following equalities:
  
$$
\begin{align}
	b^x b^y  &= b^{x+y}\\
	&\\
	(b^x)^y&= b^{xy}\\
	&\\
	\frac{b^x}{b^y} &= b^{x-y}\\
	&\\
	(bc)^x &= b^x c^x\\
\end{align}
$$

- These equalities are always true for any positive real numbers b, c, and any real numbers x, and y.

### Logarithm Function

- Exponential function is one-to-one and onto, so it has an inverse.
- Logarithm function is the inverse of the exponential function.
- For real number b > 0 and b ≠ 1, log<sub>b</sub>:  ℝ<sup>+</sup>→ ℝ is defined as:
$$
b^x = y ~~~~\Leftrightarrow~~~~\log_b (y) = x
$$
- The parameter b is called the base of the logarithm in the expression log<sub>b</sub>(y).
- A graph of b<sup>x</sup> and log<sub>b</sub>(y):
![](Discrete%20Structures%20-%20CECS228/attachments/logarithm-function-graph.png)

### Properties of Logarithms

- For any positive numbers b, c, x, and y, such that b ≠ 1 and c ≠ 1, the following equalities are always true:
$$
\begin{align}
	\log_b(xy) &= \log_b x + \log_b y\\
	&\\
	\log_b\left( \frac x y  \right) &= \log_b x - \log_b y\\
	&\\
	\log_b(x^y) &= y \log_b x\\
	&\\
	\log_c x &= \frac{\log_b x}{\log_b c}\\
\end{align}
$$
### Strictly Increasing or Decreasing
- Function f is strictly increasing if x<sub>1</sub> < x<sub>2</sub>, then f(x<sub>1</sub>) < f(x<sub>2</sub>).
  I.e. Always has a postive slope.
- Function f is strictly decreasing if x<sub>1</sub> < x<sub>2</sub>, then f(x<sub>1</sub>) > f(x<sub>2</sub>).
	I.e. Always has a negative slope.

- If b > 1, then f(x) = b<sup>x</sup> and f(x) = log<sub>b</sub>(x) are strictly increasing.
- The fact that both functions are strictly increasing can help in approximating their values.

<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
	<div style="white-space: pre;">
		<u>Approximate log<sub>3</sub>(420)</u>
		
		3<sup>6</sup> = 729  
		3<sup>5</sup> = 243
		  
	  log<sub>3</sub>(243) = 5 
		log<sub>3</sub>(729) = 6
		
		∴ 5 &lt; log<sub>3</sub>(420) &lt; 6
		
	</div>
</div>

### Population Growth

- Population growth is modeled using an exponential function, where the population p of lizards on an island at time t is described by liz(t) = p•bt, for some number b. 

- The value of b determines the rate at which the lizard population increases. 

- Once the function liz(t) is developed, questions such as the time it takes to reach a certain population can be answered.

- The population is modeled by the following equation:

$$
n = p \cdot b^t \Leftrightarrow \frac n p = b^t
$$

- The number of days for the population to reach n would be approximately log<sub>b</sub>(<sup>n</sup>/<sub>p</sub>).

### Divide-and-conquer

- Divide-and-conquer solves problems by dividing them into two groups, solving each group separately, and combining the solutions.
- Sorting a list of numbers can be done by dividing the list in half, sorting each half, and merging the two sorted lists.
- The logarithm function is important for analyzing these algorithms.

### Ingrid's chocolates:

- Ingrid has n chocolates.
  
<u>Ingrid has n = 2<sup>k</sup> chocolates</u>
- If Ingrid's bag has a number of chocolates that is a power of two (n = 2<sup>k</sup> for non-negative integer k), she can divide them evenly with each friend she meets.
- In this case, Ingrid starts with 2<sup>k</sup> chocolates.
- Each friend takes half of the chocolates, 2<sup>(k-1)</sup>, and the exponent is reduced by 1 each time.
- This continues until each friend has just one chocolate, 2<sup>0</sup> = 1.
- The number of friends Ingrid can meet is k = log<sub>2</sub>(n).

Ingrid has 19 chocolates

- If n is not a power of 2, then log<sub>2</sub>(n) is not an integer
- The number of encounters with friends must be a whole number
- Ingrid will have to divide her pile of chocolates unevenly at some point
- If she keeps the larger half, then she can divide her chocolates in half $\lceil \log_2 n \rceil$ times.
- If she keeps the smaller half, then she can divide her chocolates in half $\lfloor \log_2 n \rfloor$ times.

  
### Dividing piles and the logarithm function

Let n and b be positive integers with b > 1. 

Consider a process in which in each step, n is replaced with $\lfloor n/b \rfloor$, until n < b. 

The process lasts for $\lfloor \log_b n \rfloor$ steps.

If instead in each step, n is replaced with $\lceil n/b \rceil$, until n = 1. The process lasts for $\lceil \log_b n \rceil$ steps.

