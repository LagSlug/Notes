
# 5.0 Boolean Algebra

- Boolean algebra is a system for working with variables that have values of either 0 or 1.
- Boolean algebra is closely related to propositional logic.
- The definitions for Boolean operations are similar to logical operations but with different notation.
- In Boolean algebra, 1 represents T and 0 represents F.

# 5.1 Introduction to Boolean Algebra

### Operations

- Boolean operations are similar to propositional operations.

#### Multiplication

- Boolean multiplication is denoted by • and follows the same rules as regular multiplication.
- The results of Boolean multiplication are the same as the logical "and" operation.

| Boolean • | Logical ∧ |
|:---------:|:---------:|
| 0 • 0 = 0 | F ∧ F = F |
| 0 • 1 = 0 | F ∧ T = F |
| 1 • 0 = 0 | T ∧ F = F |
| 1 • 1 = 1 | T ∧ T = T |

#### Addition

- Boolean addition uses the symbol "+" and follows the same rules as standard addition.
- Except 1 + 1 ≠ 2, since 2 is not an element of {0, 1}.
- The results of Boolean addition are the same as the logical "or" operation.

|  Boolean + | Logical ∨ |
|:----------:|:---------:|
|  0 + 0 = 0 | F ∨ F = F |
|  0 + 1 = 1 | F ∨ T = T |
|  1 + 0 = 1 | T ∨ F = T |
|  1 + 1 = 1 | T ∨ T = T |

#### Complement

- Complement of an element is denoted by a bar symbol.
- Complementing a Boolean value is similar to applying the "not" operation in logic.
- The expression under a complement operation is evaluated before the operation is applied.

| Boolean complement | Logical ¬ |
|:------------------:|:---------:|
|        0 = 1       |   ¬F = T  |
|        1 = 0       |   ¬T = F  |

### George Boole's and Digital Logic

- George Boole defined Boolean algebra in the mid-19th century.
- Computers use 0s and 1s as their native language.
- Boolean algebra is the basis of computer circuit design.
- Vacuum tubes were used to store information as on or off states (1s and 0s).
- Today, high and low voltage states represent 1s and 0s in computer components.
- The foundation of computer circuitry is still based on Boolean algebra.
- The field of computer science that designs computer circuitry is called <u>digital logic</u>.
  
### Claude Shannon and Telephone Switching Networks

- <u>Claude Shannon</u> noticed the connection between Boolean algebra and telephone switching networks as a graduate student at MIT in the late 1930s.
- He showed that Boolean algebra could be used to simplify electronic switches used in telephone exchanges at the time.
- Shannon's study focused on electrical circuits, which have a light that illuminates if the circuit forms a closed loop.
- A circuit contains switches that are either closed or open, and the setting of the switches determines whether the circuit is closed.

### Boolean Logic in Circuits
#### And Circuit
![](Discrete%20Structures%20-%20CECS228/attachments/and-switch-circuit-diagram.svg)

- When both switches are closed, the LED will recieve current.

#### Or Circuit
![](Discrete%20Structures%20-%20CECS228/attachments/or-switch-circuit-diagram.svg)

- When either switch is closed, the LED will recieve current.

### Variables and Expressions

- <u>Boolean variables</u> have a value of 1 or 0.
- <u>Boolean expressions</u> are built up by applying Boolean operations to Boolean variables or constants.
- The value of a Boolean expression can depend on the order of operations.

### Operator Precedence

- Precedence rules exist to determine the correct order of operations.

| Precedence |                     Boolean Operator                      | Name                                  |
|:----------:|:---------------------------------------------------------:|:------------------------------------- |
|     0      |                           a ⋅ b                           | Multiplication                        |
|     1      |                           a + b                           | Addition                              |
|     \*     |                        (a + b) ⋅ c                        | Parentheses override precedence rules |
|     \*\*     | a + <span style="text-decoration: overline;">b + c</span> | Complement are given precedence as parentheses                                      |

### Best Practices

- It is good practice to use parentheses for readability when applying the complement operation, except when it is applied to a single variable or the entire expression.
- When both inputs to the • operation are variables, the expression x • y can be written as xy for more compact expressions.

### Boolean Equivalence

- Equivalence between two Boolean expressions is determined by checking if they have the same value for every possible combination of assigned variable values.
- The symbol (≡) denotes logical equivalence in propositional logic, while (=) is used in Boolean algebra.
- Boolean algebra follows the same laws (pairs of equivalent expressions) as propositional logic.

### Laws

| Law               | Definition                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                 |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Idempotent        | x + x = x                                                                                                                                                                                                                                                                                                                       | x •  x = x                                                                                                                                                                                                                                                                                                                      |
| Associative       | (x + y) + z = x + (y + z)                                                                                                                                                                                                                                                                                                       | (x • y)z = x(y ⋅ z)                                                                                                                                                                                                                                                                                                             |
| Commutative       | x + y = y + x                                                                                                                                                                                                                                                                                                                   | x • y = y ⋅ x                                                                                                                                                                                                                                                                                                                   |
| Distributive      | x + (y • z) = (x + y)(x + z)                                                                                                                                                                                                                                                                                                    | x • (y + z) = (x • y) + (x • z)                                                                                                                                                                                                                                                                                                 |
| Identity          | x + 0 = x                                                                                                                                                                                                                                                                                                                       | x • 1 = x                                                                                                                                                                                                                                                                                                                       |
| Domination        | x + 1 = 1                                                                                                                                                                                                                                                                                                                       | x • 0 = 0                                                                                                                                                                                                                                                                                                                       |
| Double complement | <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;"><span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span></span> = x                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                 |
| Complement        | x = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> = 1 <br />  <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">0</span> = 1                                                                                             | x • <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> = 0 <br />  <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">1</span> = 0                                                                                             |
| De Morgan's       | <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x + y</span> = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> • <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span> | <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x • y</span> = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span> |
| Absorption        | x + (x • y) = x                                                                                                                                                                                                                                                                                                                 | x • (x + y) = x                                                                                                                                                                                                                                                                                                                 |

- Boolean algebra laws apply similarly to propositional logic laws to demonstrate equivalence between two Boolean expressions.
  
### Set Operation Analogs

| Boolean operation/constant |       Set operation       |
|:--------------------------:|:-------------------------:|
|       Multiplication       |      Intersection: ∩      |
|          Addition          |          Union: ∪         |
|         Complement         | Set complement: <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">X</span> = A - X |
|              1             |      the whole set A      |
|              0             |             ∅             |

- The power set of A satisfies the conditions of a Boolean algebra.
- The {0, 1} set along with complement, +, and • operations is also an instance of a Boolean algebra.
- The {0, 1} Boolean algebra is commonly used in modern digital logic.
- The term "Boolean algebra" can refer to either the {0, 1} set or a general class of sets and operations.
- It is important to be aware of both meanings to avoid confusion.

### Examples

##### 1 )      (<span style="text-decoration: overline;">x + 0</span>)( <span style="text-decoration: overline;">y</span> + <span style="text-decoration: overline;">z</span> )
$$
\begin{align}
	\text{Let $x = 0$, $y = 1$, $z = 0$ } \\ \\
	(\overline{x + 0})
	(\overline{y}+\overline{z}) &= (\overline{0 + 0})(\overline{1}+\overline{0}) \\ &= (\overline{0})(\overline{1}+\overline{0}) \\ &= (\overline{0})(0 + 1) \\ &= 1 (0 + 1) \\ &= 1\cdot 1 \\ &= 1 \end{align}
$$


##### 2 )      (a + <span style="text-decoration: overline;">b + c</span>) ⋅ d 

- The tuple (a, b, c, d) represents a 4-bit number, so each entry can be either 1 or 0.
- Since a 4-bit number has are 2<sup>4</sup> possible values, there are 16 possible values for (a, b, c, d) .

<u>Symbolic Conversion</u>

|   | Expression                                                                                                        | Reasoning              |
|:-:|-------------------------------------------------------------------------------------------------------------------|------------------------|
| 0 | ( a + <span style="text-decoration: overline;">b + c</span> ) ⋅ d                                                 |                        |
| 1 | ( a ∨ <span style="text-decoration: overline;">b ∨ c</span> ) ∧ d                                                 | Addition equivalence   |
| 2 | ( a ∨ ( <span style="text-decoration: overline;">b</span> ∧ <span style="text-decoration: overline;">c</span> )) ∧ d | De Morgan's Law        |
| 3 | ( a ∨ ( ¬b ∧ ¬c )) ∧ d                                                                                               | Compliment equivalence |

<u>Truth Table</u>

| a | b | c | d | ((a ∨ (¬b ∧ ¬c)) ∧ d) |
|:-:|:-:|:-:|:-:|:---------------------:|
| F | F | F | F |           F           |
|   |   |   |   |          ...          |
| T | F | F | T |           T           |
|   |   |   |   |          ...          |
| T | F | T | F |           F           |
|   |   |   |   |          ...          |
| T | T | T | T |           T           |



##### 3 )      xy + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span>y + zy

<u>Reduced the Expression</u>

|     | Expression                                                                                                                        | Reason           |
| --- | --------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| 0   | (x • y) + (<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> • y) + (z • y) |                  |
| 1   | (x • <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> • z) + y             | Distributive Law |
| 2   | (0 • z) + y                                                                                                                       | Complement Laws  |
| 3   | 0 + y                                                                                                                             | Domination Law   |
| 4   | y                                                                                                                                 | Identity Law     |


# 5.2 Boolean Functions

A <u>boolean function</u> operates on boolean values (true or false) and returns a boolean value as a result.

<div style="display: flex; justify-content: center;">
	<div style="display: inline-block; border: 1px solid; padding: 0px 40px 0px 10px; ">
		<div style="padding: 20px;">
				A Boolean function maps Boolean input values to the set <span style="white-space: nowrap;">{0, 1}</span>.
				<br />
				<br />
				Let B = {0, 1}
			  <ul>
				  <li />B<sup>k</sup> is the set of all k-tuples over B.
					<li />A Boolean function with k input variables maps<span style="white-space: nowrap;"> B<sup>k</sup> to B</span>.
				</ul>
				<br />
				E.g.
				<br />
				<br />
				f: B<sup>3</sup> → B, where B = {0, 1}
				<br/>
				f(u, r, t) = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">(u + r)</span> - t
				<br />
				<br />
				f(1, 1, 0) = 0
		</div>
	</div>
</div>


### Input/Output Table

- An <u>input/output</u> table showing the output value for every possible combination of input values can be used to define a Boolean function.

#### Example: How to Safely Enrich Uranium

- Consider a Boolean function with 3 inputs that returns a boolean indicating whether a uranium enrichment process is operating within safe parameters.

Let 
	f(v, r, h) = v • r  • h

Where
	v = Centrifuge is operating at 50k RPM
	r = Flow Rate is 100 grams per hour
	h = Temperature is 30° C


The function can be transliterated to propositional logic.
V ∧ R ∧ H

The input/output table is just the truth table of this expression.

|  v  |  r  |  h  | f(v, r, h) | 
|:---:|:---:|:---:|:----------:|
|  T  |  T  |  T  |     T      |
|  T  |  T  |  F  |     F      |
|  T  |  F  |  T  |     F      |
|  T  |  F  |  F  |     F      |
|  F  |  T  |  T  |     F      |
|  F  |  T  |  F  |     F      |
|  F  |  F  |  T  |     F      |
|  F  |  F  |  F  |     F      |

- An input/output table for a Boolean function with k input variables requires 2<sup>k</sup> rows.
- Using a table to define a Boolean function is only feasible for functions with a small number of input variables due to the large number of rows required.

### Reversing Input/Output Tables

Consider the following table

|  x  |  y  |  z  | f(x, y, z) |     |
|:---:|:---:|:---:|:----------:| --- |
|  0  |  0  |  0  |     0      |     |
|  0  |  0  |  1  |     0      |     |
|  0  |  1  |  0  |     0      |     |
|  0  |  1  |  1  |     1      | <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span>•y•z    |
|  1  |  0  |  0  |     1      | x•<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span>•<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">z</span>    |
|  1  |  0  |  1  |     1      | x•<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span>•z     |
|  1  |  1  |  0  |     0      |     |
|  1  |  1  |  1  |     1      | x•y•z    |

Find an equivalent Boolean expression for f
1. Construct a term of the form x•y•z for each row where f(x, y, z) = 1
2. Add together terms.
  
$$
f(x,y,z) = \overline{x}yz + x\overline{y}\overline{z} + x\overline{y}z + xyz
$$

#### Formal Description of Constructing Boolean Expression

- To construct a Boolean expression equivalent to a Boolean function defined by an input/output table, minterms and literals must be defined.
- A <u>literal</u> is a Boolean variable or the complement of a Boolean variable.
- A <u>minterm</u> is a product of literals where each literal is either a variable or the complement of a variable.
- E.g. xyz and x̅y̅z̅ are minterms for a Boolean function with input variables x, y, and z.
- However, yz is not a minterm because variable x is missing from the term.
- To create a Boolean function equivalent to a function defined in a table, create a sum of minterms where the set of minterms included in the sum correspond to rows in the table where the function's value is 1.

# 5.3 Disjunctive & Conjunctive Normal Form

- For computer storage and manipulation of Boolean expressions (such as in automated reasoning systems), it is useful to have standardized expressions.
  
### Disjunctive Normal Form

- A Boolean expression that is a sum of products of literals is said to be in <u>disjunctive normal form</u> (DNF).
- The term "disjunctive" comes from propositional logic and reflects the mathematical equivalence between Boolean algebra and propositional logic.
  
<div style="display: flex; justify-content: center;">
	<div style="display: inline-block; border: 1px solid; padding: 40px; ">
		<div style="">
			<h4><u>Definition of Disjunctive Normal Form</u></h4><br /><br />
			A disjunctive normal form (DNF) expression has the form:<br />
			<br />
			<div style="text-align: center;">c<sub>1</sub> + c<sub>2</sub> + .... + c<sub>m</sub></div>
			<br />
			where each c<sub>j</sub> for j ∈ {1, …, m} is a product of literals.
			<br /><br />
			E.g.<br />
			<div style="text-align: center;">
				<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span>y<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">z</span> + x<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span> + w + w<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span>z
			</div>
			<br />
			<ul>
				<li />The expression is a sum of terms.
				<li />Each term is the product of literals (x, y, z, w).
				<li />Complement operators are applied to variables singularly.
				<li />There is no addition within a term.
			</ul>
		</div>
	</div>
</div>


- A <u>term</u> in a disjunctive normal form expression can be a single literal or a product of literals.
- An expression with only one term, such as xyz, is also considered to be in disjunctive normal form.
- In a DNF expression, multiplication can only be applied to literals, and expressions of the form (x + y)z are not allowed.
- Every Boolean function can be represented in disjunctive normal form.
- The procedure to turn a table representation (i.e. input/output tables) of a Boolean function into a Boolean expression produces an expression in DNF.  
- It is important to note that there may be multiple expressions in DNF that correspond to the same function.

#### Examples

Which expressions are in disjunctive normal form?

1. xy + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>
2. <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x + y</span>
3. x + y + z
4. xy<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>
5. (x + y)<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>

##### Answer Key
1. DNF
2. Not DNF
3. DNF
4. DNF
5. Not DNF

### Conjunctive Normal Form

- A Boolean expression that is a product of sums of literals is said to be in <u>conjunctive normal form</u> (CNF).
- Each term in the product that is a sum of literals is called a <u>clause</u>.
- CNF expressions are often used to express a set of constraints in a computational problem using logic.
- In a CNF expression, addition can only be applied to literals, and expressions of the form <span style="white-space: nowrap;">(x · y) + z</span> are not allowed.

<div style="display: flex; justify-content: center;">
	<div style="display: inline-block; border: 1px solid; padding: 40px; ">
		<h4><u>Definition of Conjunctive Normal Form</u></h4><br />
		A conjunctive normal form (CNF) expression has the form:
		<br /><br />
		<div style="text-align: center;">d<sub>1</sub> • d<sub>2</sub> • .... • d<sub>m</sub></div>
		<br />
		where each d<sub>j</sub> for j ∈ {1, …, m} is a sum of literals. 
		<br />
		Each d<sub>j</sub> is called a clause.<br /><br />
		E.g.<br />
		<div style="text-align: center;">(x + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span> + z) • (x + y) • (w<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span>) • (z)</div>
		<ul>
			<li />The expression is a product of four clauses.
			<li />Complement operators are applied to variables singularly.
			<li />There is no multiplication within a clause.
		</ul>
	</div>
</div>

- The clauses in a CNF expression can be single literals or a sum of literals.
- A CNF expression with only one clause, such as x + y, is also considered to be in conjunctive normal form.
- In a CNF expression, addition can only be applied to literals, and expressions of the form xy + z are not allowed.
- It is important to note that a CNF expression can represent any Boolean function, but there may be multiple CNF expressions that correspond to the same function.
  
#### Examples

Which expressions are in conjunctive normal form?

1. z(xy + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>)
2. (x + y + z)(<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span> + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span>)
3. <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">(x + y)</span>(x + y)
4. (x + y + z)<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>
5. x + y + z
6. xy<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">w</span>
   
##### Answer Key
1. Not CNF
2. CNF
3. Not CNF
4. CNF
5. CNF
6. CNF
   


# 5.4 Functional completeness

- A set of operations is functionally complete if any Boolean function can be expressed using only operations from the set.
- The set {addition, multiplication, complement} is functionally complete because any Boolean function can be expressed in disjunctive normal form which only uses these three operations.
  
### Incomplete Set of Operations

- Some hardware may lack either addition or multiplication operations.
- If addition is lacking, but multiplication and complement operations are available, De Morgan's law can be used to achieve functional completeness.
- Similarly, if multiplication is lacking, but addition and complement operations are available, the same technique can be applied.
- De Morgan's law allows for the replacement of the missing operation to achieve functional completeness in either case.

#### De Morgan's Law with 2-Terms

<div style="display: flex; justify-content: center;">
	<div>
	x + y = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;"><span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> • <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span></span>
	</div>
</div>

<div style="display: flex; justify-content: center;">
	<div>
	x • y = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;"><span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> + <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">y</span></span>
	</div>
</div>

#### De Morgan's Law with n-Terms

$$
\begin{aligned}
a_1 + a_2 + \cdots + a_n 
&= 
\overline{
\overline{a_1} \cdot \overline{a_2} \cdots \overline{a_n}
}
\\ \\
a_1 \cdot a_2 \cdots a_n 
&= 
\overline{
\overline{a_1} + \overline{a_2} + \cdots + \overline{a_n}
}
\end{aligned}
$$

#### Missing Addition?

- An arbitrary Boolean function can be expressed using only multiplication and complement operations by following these steps:
    1.  Start with the input/output table for the function.
    2.  Find a DNF expression that is equivalent to the function.
    3.  Repeatedly apply De Morgan's law to eliminate each addition operation.

$$
\begin{aligned}
\text{De Morgan's Law}
\\ \\
x + y = \overline{\bar{x} \cdot \bar{y}}
\end{aligned}
$$

- The second step uses the sum of minterms method to generate a DNF expression equivalent to a given input/output table.
  
##### Examples
Use De Morgan's law to find an equivalent Boolean expression which lacks addition operations.

1.  $\overline{x} \cdot \overline{y} + \overline{x}y + xy$
   
2.  $\overline{x}y\overline{z} + x\overline{y}z + xyz$

##### Solutions

1. 
  
$$
\begin{aligned}
\overline{x} \cdot \overline{y} + \overline{x}y + xy
\\
\\
\overline{
	(\overline{\overline{x} \cdot \overline{y}} 
	\cdot \overline{\overline{x}y}
	)} 
+ xy
& \quad{}\text{De Morgan's Law}
\\
\\
\overline{\overline{\overline{
	\overline{\overline{x} \cdot \overline{y}} 
	\cdot \overline{\overline{x}y}
	}} 
\cdot 
\overline{xy}}
& \quad{}\text{De Morgan's Law}
\\
\\
\overline{
	\overline{\overline{x} \cdot \overline{y}} 
	\cdot \overline{\overline{x}y}
	
\cdot 
\overline{xy}}
& \quad{}\text{Double Complement Law}
\end{aligned}
$$

2. 
   
$$
\begin{aligned}
\overline{x}y\overline{z} + x\overline{y}z + xyz
\\
\\
\overline{\overline{\overline{x}y\overline{z}} 
\cdot 
\overline{x\overline{y}z} 
\cdot 
\overline{xyz}}
& \quad{}\text{De Morgan's Law}
\\
\\
\end{aligned}
$$

#### Missing Multiplication?

- An arbitrary Boolean function can be expressed using only addition and complement operations by following these steps:
    1.  Start with the input/output table for the function.
    2.  Find a DNF expression that is equivalent to the function.
    3.  Repeatedly apply De Morgan's law to eliminate each multiplication operation.

$$
\begin{aligned}
\text{De Morgan's Law}
\\ \\
x \cdot y = \overline{\bar{x} + \bar{y}}
\end{aligned}
$$

- The resulting Boolean expression uses only addition and complement and is functionally complete with the set {addition, complement}.

##### Examples
Use De Morgan's law to find an equivalent Boolean expression which lacks multiplication operations.

1.  x • y + z

2.  x • y • z
   
##### Solutions

1. $\overline{\overline{x} + \overline{y}} + z$

2. $\overline{\overline{x} + \overline{y} + \overline{z}}$

### NAND and NOR Operations

- Using a single type of circuit to implement each operation can improve hardware efficiency and costs.
- Addition, multiplication, and complement operations are not functionally complete individually.
- To achieve functional completeness in such a circuit, a new operation must be introduced.
  
- The <u>NAND</u> (Not And) operation is represented by ↑ and is equivalent to <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x • y</span>.
- The <u>NOR</u> (Not Or) operation is represented by ↓ and is equivalent to <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x + y</span>.

<div style="display: flex; justify-content: center; gap: 20px; text-align: center;">
<table class="grayscale lined td-padding">
  <thead>
    <tr>
      <th colspan="3">NAND</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x<br /></td>
      <td>y</td>
      <td>x ↑ y</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<table class="grayscale lined td-padding">
  <thead>
    <tr>
      <th colspan="3">NOR</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>x<br /></td>
      <td>y</td>
      <td>x ↓ y</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>

#### Proving NAND is Functionally Complete

- To prove that a set of operations is functionally complete, a known functionally complete set can be used to demonstrate how to compute each operation with the new set.

- The set {multiplication, complement} can be used to illustrate this approach and show that {NAND} is functionally complete.

##### Proof of Complement

- The identity <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> = x ↑ x can be verified by filling out a simple input/output table.
  
<div style="display: flex; justify-content: center; text-align: center;">
	<table class="grayscale lined td-padding"><thead><tr><th>x</th><th>x ↑ x</th><th><span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span></th></tr></thead><tbody><tr><td>1<br></td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr></tbody></table>
</div>



##### Proof of Multiplication

- Show that $xy = (x ↑ y) ↑ (x ↑ y)$

$$
\begin{aligned}

 x \cdot y
 ~&≡~ x ∧ y
 && \quad{}\text {By Equality} 
 \\ \\
 
 ~&≡ ¬¬(x ∧ y)
 && \quad{}\text {Double Negation} 
 \\ \\
 
 ~&≡ ~ ¬(x ↑ y)
 && \quad{}\text {Definition of Nand} 
 \\ \\
 
 ~~&≡~ \overline{x ↑ y}
 && \quad{}\text{By Equality}
 \\ \\
 
 
 ~&≡ ~\overline{a}
 && \quad{}\text{Let } a = x ↑ y
 \\ \\
 
 
 ~&≡ ~ a ↑ a
 && \quad{}\text{Compliment Identity}
 \\ \\
 
 x \cdot y
 ~&≡ ~(x ↑ y) ↑ (x ↑ y)
 && \quad{}\text{Substitution. ■}
 \\ \\
 
\end{aligned}
$$

##### Proof of Addition

- Show that x + y = (x ↑ x) ↑ (y ↑ y)

$$
\begin{aligned}
 x + y
 ~&≡~~ x ∨ y 
 && \quad{}\text {By Definition of Addition} 
 \\ \\
 
 ~&≡~~ \overline{(~\overline{x} ∧ \overline{y}~)}
 && \quad{}\text{De Morgan's Law}
 \\ \\
	
 ~&≡~~ \overline{(~a ∧ b~)}
 && \quad{}\text{Let $a = \overline{x}, b = \overline{y}$}
 \\ \\
 
 ~&≡~~ a ↑ b
 && \quad{}\text{By Definition of NAND}
 \\ \\
 
 ~&≡~~ \overline{x} ↑ \overline{y}
 && \quad{}\text{Substitution}
 \\ \\
 
 ~&≡~~ (x ↑ x) ↑ (y ↑ y)
 && \quad{}\text{Complement Identity. ■}
 \\ \\
\end{aligned}
$$


#### Proving NOR is Functionally Complete

- The nor operation is proven in the same way as the nand operation by demonstrating how to compute each operation with nor alone.

##### Proof of Complement

- The identity <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span> = x ↓ x can be verified by filling out a simple input/output table.
  
<div style="display: flex; justify-content: center; text-align: center;">
	<table class="grayscale lined td-padding"><thead><tr><th>x</th><th>x ↓ x</th><th><span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span></th></tr></thead><tbody><tr><td>1<br></td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr></tbody></table>
</div>

- Note the congruencies:
  x ↓ x = x ↑ x = <span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">x</span>

- This makes sense grammatically, since "not x and y" is the same as saying "not x or y".

##### Proof of Multiplication

- Show that x • y = (x ↓ x) ↓ (y ↓ y)
  
$$
\begin{aligned}
 x \cdot y
 ~&≡~~ x ∧ y 
 && \quad{}\text {By Equality} 
 \\ \\
 
 ~&≡~~ \overline{(~\overline{x} ∨ \overline{y}~)}
 && \quad{}\text{De Morgan's Law}
 \\ \\
	
 ~&≡~~ \overline{(~a ∨ b~)}
 && \quad{}\text{Let $a = \overline{x}, b = \overline{y}$}
 \\ \\
 
 ~&≡~~ a ↓ b
 && \quad{}\text{By Definition of Nor}
 \\ \\
 
 ~&≡~~ \overline{x} ↓ \overline{y}
 && \quad{}\text{Substitution}
 \\ \\
 
 ~&≡~~ (x ↓ x) ↓ (y ↓ y)
 && \quad{}\text{Complement Identity. ■}
 \\ \\
\end{aligned}
$$



##### Proof of Addition

- Show that x + y = (x ↓ y) ↓ (x ↓ y)

$$
\begin{aligned}

 x + y
 ~&≡ x ∨ y
 && \quad{}\text {By Equality} 
 \\ \\

 
 ~&≡ ¬¬(x ∨ y)
 && \quad{}\text {Double Negation} 
 \\ \\
 
 
 ~&≡ ¬(x ↓ y) 
 && \quad{}\text {Definition of Nor} 
 \\ \\
 
 
 ~~&≡~ \overline{x ↓ y}
 && \quad{}\text{By Equality}
 \\ \\
 
 
 ~&≡ ~\overline{a}
 && \quad{}\text{Let } a = x ↓ y
 \\ \\
 
 
 ~&≡ ~ a ↓ a
 && \quad{}\text{Compliment Identity}
 \\ \\
 
 x + y
 ~&≡ ~(x ↓ y) ↓ (x ↓ y)
 && \quad{}\text{Substitution. ■}
 \\ \\
 
\end{aligned}
$$

# 5.5 Boolean Satisfiability

<u>Boolean satisfiability</u> (SAT) determines if a given Boolean expression can be assigned variable values that make it evaluate to 1.
  
<u>Satisfiable vs Unsatisfiable</u>

- A Boolean expression is *satisfiable* if it can be evaluated to 1 by assigning values to its input variables.
- If it is impossible to assign values to the input variables to evaluate the expression to 1, the expression is *unsatisfiable*.
- An assignment *satisfies* a Boolean expression if it causes the expression to evaluate to 1.

<u>Challenges and Limits</u>

- To prove that a Boolean expression is unsatisfiable, we must consider all possible variable assignments.
- The time required for this task is proportional to 2<sup>n</sup>, where n is the number of variables in the expression.
- Despite many years of research, there is no known provably efficient method for solving SAT.

#### Examples
Are the following Boolean expressions satisfiable?

1. $f(x, y) = (x + y)\overline{x}(x + \overline{y})$
2. $g(x, y, z) = ( x + y + z )\overline{y}(\overline{x} + y)$

##### Solutions

1. $f(x, y) = (x + y)\overline{x}(x + \overline{y})$

| x | y | $f(x, y) = (x + y)\overline{x}(x + \overline{y})$ |  $f(x, y) |
|:-:|:-:|:-------------------------------------------------:|:---------:|
| 1 | 1 | $f(1, 1) = (1 + 1)\overline{1}(1 + \overline{1})$ | 1•0•1 = 0 |
| 1 | 0 | $f(1, 0) = (1 + 0)\overline{1}(1 + \overline{0})$ | 1•0•1 = 0 |
| 0 | 1 | $f(0, 1) = (0 + 1)\overline{0}(0 + \overline{1})$ | 1•1•0 = 0 |
| 0 | 0 | $f(0, 0) = (0 + 0)\overline{0}(0 + \overline{0})$ | 0•1•1 = 0 |

- There are no possible variable assignments that make the expression evaluate to 1, therefore it is unsatisfiable.
   
2. $g(x, y, z) = ( x + y + z )\overline{y}(\overline{x} + y)$

| x | y | z | $( x + y + z )\overline{y}(\overline{x} + y)$ | g(x, y, z) |
|:-:|:-:|:-:|:-------------------------------------------:|:----------:|
| 1 | 1 | 1 | $( 1 + 1 + 1 )\overline{1}(\overline{1} + 1)$ |  1•0•1 = 0 |
| 1 | 1 | 0 |  $(1 + 1 + 0)\overline{1}(\overline{1} + 1)$  |  1•0•1 = 0 |
| 1 | 0 | 1 | $( 1 + 0 + 1 )\overline{0}(\overline{1} + 0)$ |  1•1•0 = 0 |
| 1 | 0 | 0 | $(1  + 0 + 0 )\overline{0}(\overline{1} + 0)$ |  1•1•0 = 0 |
| 0 | 1 | 1 |  $( 0 + 1 + 1)\overline{1}(\overline{0} + 1)$ |  1•0•1 = 0 |
| 0 | 1 | 0 | $(0  + 1 + 0 )\overline{1}(\overline{0} + 1)$ |  1•0•1 = 0 |
| 0 | 0 | 1 | $( 0 + 0 + 1 )\overline{0}(\overline{0} + 0)$ |  1•1•1 = 1 |
| 0 | 0 | 0 | $( 0 + 0 + 0 )\overline{0}(\overline{0} + 0)$ |  0•1•1 = 0 |

- The expression g evaluates to 1 when (x, y, z) = (0, 0, 1), therefore the expression is satisfiable.

### Satisfying Disjunctive Normal Form

- If a Boolean expression is in Disjunctive Normal Form (DNF), determining its satisfiability is straightforward.

- An expression in DNF is satisfiable if and only if there is a term that does not contain a variable and its own negation.
	
	I.e. a Boolean expression in DNF is satisfiable if at least one term is not a contradiction.

##### Example: $x\overline{y}z\overline{x} + \overline{w}xy\overline{z} + \overline{w}xw\overline{x} + xyz\overline{z}$

- The second term of the expression, $\overline{w}xy\overline{z}$, does not contain a variable and its negation.
- The expression can be satisfied by assigning values of:
   $w=0$, $x=1$, $y=1$, and $z=0$.

### Satisfying Conjunctive Normal Form

- Unlike DNF expressions, real-world problems are often naturally expressed in Conjunctive Normal Form (CNF) which makes it more difficult to determine their satisfiability.

- In CNF, each clause represents a constraint that must be satisfied.  
- An individual clause is satisfied by a variable assignment if the assignment causes the clause to evaluate to 1.
- The entire CNF expression is the product of all the clauses, and it evaluates to 1 only if all clauses are satisfied.

##### Example: $(w + \overline{x} + z)(x + y + \overline{z})(\overline{x} + \overline{y} + z)(w + \overline{y} + \overline{z})$

Let w = 0, x = 0, y = 0, z = 0

(0 + 0 + 0)(0 + 0 + 1)(0 + 1 + 0)( 0 + 1 + 1)
0•1•1•1 = 0

Let w = 1, x = 1, y = 1, z = 1

(1 + 1 + 1)(1 + 1 + 0)(1 + 0 + 1)( 1 + 0 + 0)
1•1•1•1 = 1

- The expression is satisfiable when (w, x, y, z) = (1, 1, 1, 1)


### Example: Scheduling Classes

- The problem of scheduling classes in a school can be formulated as a Boolean satisfiability problem.

<u>For example</u>
  
Consider a school with 26 classes, offered throughout the day across 5 periods.
  
Assuming that each class is represented by a unique starting character in the alphabet, we can represent the entire set of classes as a collection of alphabetic characters.

E.g.
{ Astronomy, ..., Zoology} ≡ { A, ..., Z }

Rules:
1. A class must be assigned to only one period.
2. All class must be assigned to some period.
3. Scheduling conflicts exist, and some classes must not belong to the same period. 
		E.g. (A, B), (B, E), (D, C), and (C, E).

- As the collection of classes grows longer, it might be necessary to use more complex sorting algorithms that can take into account other factors such as distance between classes or the availability of teaching staff.

##### Solution

- To solve the class scheduling problem, a Boolean expression will be created, described by the set of rules established.

- Since there are 26 classes and 5 periods, there are 130 (26 • 5) class to period assignments required to describe a complete schedule.

- Every variable assignment represents a possible schedule, but not all combinations are valid due to conflicts.

Let 
X<sub>an</sub> = class a is scheduled for period n.
C<sub>ab</sub> = class a is in conflict with class b. 

E.g. 
X<sub>U1</sub> = underwater-basket-weaving is scheduled for period 1.
C<sub>FN</sub> = fight-club is in conflict with nap-time.

- These variables can be put into a 2D matrix, which then describes a complete schedule.

- A Boolean expression will be created to determine if there are any conflicts in the class schedule.

- The expression is satisfiable only if a valid, conflict-free schedule can be found.

- The function will be a product of terms, with each term representing a constraint that must be satisfied for the schedule to be valid.
  
- Asserting that X<sub>an</sub> must be assigned to a period, but must not be assigned to more than one period, constrains the expression:
  
  ${(x_{B1} + \cdots + x_{B5})\overline{(x_{B1} \cdots x_{B5})}}$

	If x<sub>B1</sub> = 1 and x<sub>B5</sub> = 1, then the expression evaluates to 0.

- Asserting that elements a and b of the tuple C<sub>ab</sub> do not conflict with one another can be constrained the same way:

	<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">(x<sub>B1</sub> • x<sub>C1</sub>)</span>•<span style="display: inline-block; border-top: 2px solid; margin-top: 5px;line-height: 18px;">(x<sub>F1</sub> • x<sub>Z1</sub>)</span>

	If x<sub>B1</sub> = 1 and x<sub>C1</sub> = 1, then the expression evaluates to 0.

<u>Constructing an Expression</u>

![](Discrete%20Structures%20-%20CECS228/attachments/zybook-5.5.8-boolean-expression.png)
Credit: [Zybooks](https://learn.zybooks.com/zybook/CSULBCECS228MehrniaSpring2023/chapter/5/section/5)

# 5.6 Gates and circuits

- Boolean algebra is used in the design and description of circuit, and circuits are constructed from electrical devices called gates.
  
- Gates receive Boolean input values and produce an output based on the input values, thereby implementing a simple Boolean function.

### Three Basic Gates: And, Or, Not (Inverter)

- There are three fundamental types of gates: 
	1. the AND gate computes Boolean multiplication, 
	2. the OR gate computes Boolean addition, 
	3. the inverter computes the complement.
	   
- The shape of a gate indicates the specific operation that it performs.

![](Discrete%20Structures%20-%20CECS228/attachments/and-or-not-gates.svg)

### Expressing Functions as Gates

- Connecting gates together can enable computation of more complex functions.

- The output of one gate can serve as input to another gate, and the output of a gate can branch and feed into multiple gates.

- By designing and connecting gates in specific ways, complex computations can be performed within an electronic device.

![](Discrete%20Structures%20-%20CECS228/attachments/zybook%20-%205.6.1%20-%20circuit%20of%20gates.png)

### Combinatorial Circuits vs Stateful Circuitry

- <u>Combinatorial circuits</u> are a type of circuit with an output value that is dependent only on the current combination of input values.
  
- Combinatorial circuits do not store information over time and therefore cannot be stateful.
  
- The distinction can be illustrated with an example of a non-combinatorial circuit, which can store one bit of information and has the ability to stabilize over time.

### Storing 1-Bit

![](Discrete%20Structures%20-%20CECS228/attachments/zybook%205.6.3%20-%201-bit%20storage%20-%201.png)

![](Discrete%20Structures%20-%20CECS228/attachments/zybook%205.6.3%20-%201-bit%20storage%20-%202.png)

### Constructing Boolean Functions from Circuits

- Every combinatorial circuit calculates a Boolean function.

![](Discrete%20Structures%20-%20CECS228/attachments/zybooks%20-%205.6.4%20-%20combinatorial%20function.png)


### Constructing Circuits from Boolean Functions

- Any Boolean expression can be implemented by a circuit such that the input/output behavior of the circuit matches the function specified by the expression.

- A systematic approach for creating a diagram of the corresponding circuit based on a Boolean expression involves arranging input variables on the left side of the diagram.

- Each operation in the Boolean expression is then applied by adding a gate that performs that operation to the diagram, following the standard precedence rules.

- Input wires to the gate originate from the gates or input values where the operation is applied, and the output wire is labeled with the outcome of the Boolean operation.

![](Discrete%20Structures%20-%20CECS228/attachments/zybooks%20-%205.6.5%20-%20%20Constructing%20a%20circuit%20from%20a%20Boolean%20expression.png)

### Designing circuits

Circuit design typically begins with an informal description of the desired function, followed by creating an input/output table describing every possible input combination.

Steps:
1. Describe the circuit in terms of inputs and outputs.
2. Create an input/output table to ensure the circuit works for every possible input combination.
3. Develop a Boolean expression equivalent to the table.
4. Construct the circuit based on the Boolean expression.
5. (Optional) Optimize the circuit.
   
#### Circuit: the Sum of Two Bits in Binary

Consider a circuit that computes the sum of two bits and outputs the result in binary. The circuit has two input variables, x and y, representing the bits to be added in base-10.

1. Circuit Description
    
    - Input variables: x and y.
    - Output variables: m and l.
    - The concated output is a 2-bit binary number.
    - Addition operation used is the usual addition, 1 + 1 = 2 in this context.
      
2. Input/Output Table
    
    - Specifies desired input/output relationships for each output variable.
    - Output labeled 'm' denotes most significant (or high-order) bit of sum.
    - Output labeled 'l' denotes least significant (or low-order) bit of sum.

<div style="display: flex; justify-content: center;">
	
	<table class="lined grayscale td-padding" style="text-align: center;">
	<thead>
	  <tr>
	    <th>x</th><th>y</th><th>m</th><th>l</th>
	    <th>x + y</th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td>0</td><td>0</td> <td>0</td><td>0</td>
	    <td>0</td>
	  </tr>
	  <tr>
	    <td>0</td><td>1</td><td>0</td><td>1</td>
	    <td>1</td>
	  </tr>
	  <tr>
	    <td>1</td><td>0</td><td>0</td><td>1</td>
	    <td>1</td>
	  </tr>
	  <tr>
	    <td>1</td><td>1</td><td>1</td><td>0</td>
	    <td>2</td>
	  </tr>
	</tbody>
	</table>	
</div>

3. Develop Boolean Expression(s)
   
   The circuit has two outputs, so there must be two expressions describing their behavior.
   a) $m = x \cdot y$
   b) $l = (x \cdot \overline{y}) + (\overline{x} \cdot y)$

4. Construct the Circuit

- Without considering optimization, the following diagram describes a circuit that will add two binary inputs algebraically.
  
![](Discrete%20Structures%20-%20CECS228/attachments/2-bit-adding-circuit.svg)

5. Optimize the Circuit

- The previous diagram can be optimized by reducing the number of components needed to achieve the same results.

- Computational work is done by each component and the output of a component can be split to feed into multiple inputs.

- Consider the AND gate responsible for the expression $x \cdot y$.

![](Discrete%20Structures%20-%20CECS228/attachments/2-bit-adding-circuit-with-highlighted-section.svg)

- The work to compute $x \cdot y$ is done with the AND gate here, so using that output twice could lead to optimization.

- Find an expression that uses the term $x \cdot y$ and is equivalent to $(x \cdot \overline{y}) + (\overline{x} \cdot y)$

$$
\begin{aligned}

(x \cdot \overline{y}) + (\overline{x} \cdot y) 
&
\\ \\
\overline{
	\overline{(x \cdot \overline{y})}
	\cdot 
	\overline{(\overline{x} \cdot y)}
}
≡
\overline{
	(\overline{x} + y)
	\cdot 
	(x + \overline{y})
}
& \quad{}\text{De Morgan's Law}
\\
\\
\overline{
	(z)
	\cdot 
	(x + \overline{y})
	}
& \quad{}\text{Let } z = \overline{x} + y
\\
\\
\overline{
	(z \cdot x)
	+
	(z \cdot \overline{y})
}
& \quad{}\text{Distributive And Over Or}

\\
\\
\overline{
	((\overline{x} + y) \cdot x)
	+
	((\overline{x} + y) \cdot \overline{y})
}
& \quad{}\text{Substitute }z

\\
\\
\overline{
	(\overline{x} \cdot x) + (x \cdot y)
	+
	(\overline{x} \cdot \overline{y}) + (y \cdot \overline{y})
}
& \quad{}\text{Distributive And Over Or }
\\
\\
\overline{
	(x \cdot y)
	+
	(\overline{x} \cdot \overline{y})
}
& \quad{}\text{Disjunction of Contradictions}

\\
\\
\overline{
	(x \cdot y)
}
\cdot
\overline{
	(\overline{x} \cdot \overline{y})
}
& \quad{}\text{De Morgan's Law}

\\
\\
\overline{
	(x \cdot y)
}
\cdot
	(x + y)

& \quad{}\text{De Morgan's Law}
\end{aligned}
$$
- The final expression is equivalent to the initial expression, and contains the term $x \cdot y$.

- The optimized expression has fewer operators than the initial expression.

- With optimization, the following diagram describes a circuit that will add two binary inputs algebraically, using fewer components than before.

![](Discrete%20Structures%20-%20CECS228/attachments/2-bit-adding-circuit-optimized.svg)

